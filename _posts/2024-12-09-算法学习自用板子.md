### AcWing

#### 题目描述

>### 1064. 小国王
>
>xxx
>
>#### 输入格式
>
>xxx
>
>#### 输出格式
>
>xxx
>
>#### 数据范围
>
>$0<N≤1000$
>
>#### 输入样例：
>
>```
>
>```
>
>##### 输出样例：
>
>

#### 算法设计

xxx

#### 完整 C++ 代码

```c++

```

xxx













# 第一章 基础算法





## 二分查找

### AcWing 789. 数的范围

#### 题目描述

>给定一个按照升序排列的长度为 $n$ 的整数数组，以及 $q$ 个查询。
>
>对于每个查询，返回一个元素 $k$ 的起始位置和终止位置（位置从 $0$ 开始计数）。
>
>如果数组中不存在该元素，则返回 `-1 -1`。
>
>#### 输入格式
>
>第一行包含整数 $n$ 和 $q$，表示数组长度和询问个数。
>
>第二行包含 $n$ 个整数（均在 $1∼10000$ 范围内），表示完整数组。
>
>接下来 $q$ 行，每行包含一个整数 $k$，表示一个询问元素。
>
>#### 输出格式
>
>共 $q$ 行，每行包含两个整数，表示所求元素的起始位置和终止位置。
>
>如果数组中不存在该元素，则返回 `-1 -1`。
>
>#### 数据范围
>
>$1≤n≤100000$
>
>$1≤q≤10000$
>
>$1≤k≤10000$
>
>#### 输入样例：
>
>```
>6 3
>1 2 2 3 3 4
>3
>4
>5
>```
>
>#### 输出样例：
>
>```
>3 4
>5 5
>-1 -1
>```

#### 算法设计







#### 完整 C++ 代码





---

## 前缀和

### AcWing 795. 前缀和

#### 题目描述

> 输入一个长度为 $n$ 的整数序列。
>
> 接下来再输入 $m$ 个询问，每个询问输入一对 $l$, $r$。
>
> 对于每个询问，输出原序列中从第 $l$ 个数到第 $r$ 个数的和。
>
> #### 输入格式
>
> 第一行包含两个整数 $n$ 和 $m$。
>
> 第二行包含 $n$ 个整数，表示整数数列。
>
> 接下来 $m$ 行，每行包含两个整数 $l$ 和 $r$，表示一个询问的区间范围。
>
> #### 输出格式
>
> 共 $m$ 行，每行输出一个询问的结果。
>
> #### 数据范围
>
> $1≤l≤r≤n$,
> $1≤n,m≤100000$,
> $−1000≤$ 数列中元素的值 $≤1000$
>
> #### 输入样例：
>
> ```
> 5 3
> 2 1 3 6 4
> 1 2
> 1 3
> 2 4
> ```
>
> #### 输出样例：
>
> ```
> 3
> 6
> 10
> ```
>



#### 算法设计

前缀和的思想用的挺多的,可以将多次的求一段连续区间和的时间复杂度从 $O(n^2)$ 优化到 $O(n)$，拓展题中添加了一道二维的前缀和，可以一块看看。

构造 $s_i=a_1+a_2+...+a_i$，通过提前预处理一个 $s$ 数组来存储累加和。

#### 完整C++ 代码

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int n, m;
int s[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {   
        int a;
        cin >> a;
        s[i] = s[i - 1] + a;
    }
    while (m--)
    {
        int l, r;
        cin >> l >> r;
        cout << s[r] - s[l - 1] << endl;
    }
    return 0;
}
```

#### 拓展

>### 796. 子矩阵的和
>
>输入一个 $n$ 行 $m$ 列的整数矩阵，再输入 $q$ 个询问，每个询问包含四个整数 $x1,y1,x2,y2$，表示一个子矩阵的左上角坐标和右下角坐标。
>
>对于每个询问输出子矩阵中所有数的和。
>
>#### 输入格式
>
>第一行包含三个整数 $n，m，q$。
>
>接下来 $n$ 行，每行包含 $m$ 个整数，表示整数矩阵。
>
>接下来 $q$ 行，每行包含四个整数 $x1,y1,x2,y2$，表示一组询问。
>
>#### 输出格式
>
>共 $q$ 行，每行输出一个询问的结果。
>
>#### 数据范围
>
>$1≤n,m≤1000$,
>$1≤q≤200000$,
>$1≤x1≤x2≤n$,
>$1≤y1≤y2≤m$,
>$−1000≤$矩阵内元素的值$≤1000$
>
>#### 输入样例：
>
>```
>3 4 3
>1 7 2 4
>3 6 2 8
>2 1 2 3
>1 1 2 2
>2 1 3 4
>1 3 3 4
>```
>
>#### 输出样例：
>
>```
>17
>27
>21
>```
>
>#### 算法剖析
>
>这是一道经典的二维前缀和模板题，这里的最终表达式有点像概率论里面那个二维联合分布函数的味道。
>
>#### 完整C++ 代码
>
>```c++
>#include <iostream>
>
>using namespace std;
>
>const int N = 1010;
>
>int n, m, q;
>int s[N][N];
>
>int main()
>{
>    cin >> n >> m >> q;
>    for (int i = 1; i <= n; i++)
>    {
>        for (int j = 1; j <= m; j++)
>        {
>            int w;
>            cin >> w;
>            s[i][j] = s[i - 1][j] + (s[i][j - 1] - s[i - 1][j - 1]) + w;
>        }
>    }
>    while (q--)
>    {
>        int x1, y1, x2, y2;
>        cin >> x1 >> y1 >> x2 >> y2;
>        cout << s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1] << endl;
>    }
>    return 0;
>}
>```

---

## 差分

### AcWing 797. 差分

#### 题目描述

>有输入一个长度为 $n$ 的整数序列。
>
>接下来输入 $m$ 个操作，每个操作包含三个整数 $l,r,c$，表示将序列中 $[l,r]$ 之间的每个数加上 $c$。
>
>请你输出进行完所有操作后的序列。
>
>#### 输入格式
>
>第一行包含两个整数 $n$ 和 $m$。
>
>第二行包含 $n$ 个整数，表示整数序列。
>
>接下来 $m$ 行，每行包含三个整数 $l，r，c$，表示一个操作。
>
>#### 输出格式
>
>共一行，包含 $n$ 个整数，表示最终序列。
>
>#### 数据范围
>
>$1≤n,m≤100000$,
>$1≤l≤r≤n$,
>$−1000≤c≤1000$,
>$−1000≤\ $整数序列中元素的值$\ ≤1000$
>
>#### 输入样例：
>
>```
>6 3
>1 2 2 1 2 1
>1 3 1
>3 5 1
>1 6 1
>```
>
>#### 输出样例：
>
>```
>3 4 5 3 4 2
>```



#### 算法设计

构造 $B$ 数组：

使得：$a_i = b_1+b_2+...+b_i$

那么我们对 $B$ 数组进行一次前缀和操作就可以得到 $a_i$。

那么就可以在 $O(n)$ 的时间由 $B$ 数组反推出 $A$ 数组。

$B$ 数组有一个好处，可以在 $O(1)$ 的时间里将 $[l, r]$ 中每一个数加上 $c$ 。

通过令 $b_l + c$ , $b_{r+1} - c$ 即可。

#### 朴素解法 C++ 代码

由$\begin{cases}
        a_i = b_1+b_2+...+b_i\\
        a_{i-1} = b_1+b_2+...+b_{i-1}
    \end{cases}$$\Rightarrow b_i = a_{i}-a_{i-1}\ \ \ \ \ (1)$ 

直接利用公式 $(1)$ $b_i = a_{i}-a_{i-1}$ 来初始化 $B$ 数组。

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int n, m;
int a[N], b[N], s[N];

int main()
{
    cin >> n >> m;
    for (int i = 1;i <= n; i++)
    {
       cin >> a[i];
       b[i] = a[i] - a[i - 1];
    }
    while (m--)
    {
        int l, r, c;
        cin >> l >> r >> c;
        b[l] += c;
        b[r + 1] -= c;
    }

    for (int i = 1; i <= n; i++)
    {
        s[i] = s[i - 1] + b[i];
        cout << s[i] << " ";
    }
    return 0;
}
```

#### 优美解法 C++ 代码

一开始 $A, B$ 数组初值都为0，已经满足差分定义了。

此时每次读取后更新A数组的值 $a_i$，其实就可以看作是对 $A$ 数组 $[i, i]$ 区间上的每一个数加上 $a_i$, 所以直接复用后面的差分代码即可完成对 $B$ 数组的初始化。

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int n, m;
int a, b[N];

void insert(int l, int r, int c)
{
    b[l] += c;
    b[r + 1] -= c;
}

int main()
{
    cin >> n >> m;
    for (int i = 1;i <= n; i++)
    {
       cin >> a;
       insert(i, i, a);               // 点金之笔，代码复用
    }
    while (m--)
    {
        int l, r, c;
        cin >> l >> r >> c;
        insert(l, r, c);
    }

    for (int i = 1; i <= n; i++)
    {
        b[i] += b[i - 1];             // 直接偷懒不再用s数组来存前缀和了
        cout << b[i] << " ";
    }
    return 0;
}
```

---

## 位运算

求 $n$ 的第 $k$ 位数字: `n >> k & 1`

$\text{lowbit}$ 算法：返回 $n$ 的最后一位1的子串，如1100返回100，10010返回10:`lowbit(n) = n & -n`

证明：$n \ \& -n = n \ \& \ (∼ n + 1)$, $-n$ means 补码

---



# 第二章 数据结构

## 滚动数组

### AcWing21. 斐波那契数列

#### 题目描述

>输入一个整数 $n$ ，求斐波那契数列的第 $n$ 项。
>
>假定从 $0$ 开始，第 $0$ 项为 $0$。
>
>#### 输入格式
>
>共一行，包含两个整数 $n$ 和 $k$ 。
>
>#### 输出格式
>
>共一行，表示斐波那契数列的第 $n$ 项。
>
>#### 数据范围
>
>$0 \le n \le39$,
>
>
>#### 输入样例：
>
>```
>36
>```
>
>#### 输出样例：
>
>```
>14930352
>```



#### 算法设计

如果只需要使用到相邻 $n$ 个状态的值，那么只需要开 $n$ 层数组即可，其中状态使用  $f(i\ \%\ n)$ 来表示即可

#### 完整 C++ 代码

```c++
#include <iostream>

using namespace std;

int dp[3];
int n;

int main()
{
    cin >> n;
    dp[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        dp[i % 3] = dp[(i - 1) % 3] + dp[(i - 2) % 3];
    }
    
    cout << dp[n % 3] << endl;
    return 0;
}
```

---

## 单链表

### AcWing 826. 单链表

#### 题目描述

>### 826. 单链表
>
>实现一个单链表，链表初始为空，支持三种操作：
>
>1. 向链表头插入一个数；
>2. 删除第 $k$ 个插入的数后面的一个数；
>3. 在第 $k$ 个插入的数后插入一个数。
>
>现在要对该链表进行 $M$ 次操作，进行完所有操作后，从头到尾输出整个链表。
>
>**注意**:题目中第 $k$ 个插入的数并不是指当前链表的第 $k$ 个数。例如操作过程中一共插入了 $n$ 个数，则按照插入的时间顺序，这 $n$ 个数依次为：第 $1$ 个插入的数，第 $2$ 个插入的数，…第 $n$ 个插入的数。
>
>#### 输入格式
>
>第一行包含整数 $M$，表示操作次数。
>
>接下来 $M$ 行，每行包含一个操作命令，操作命令可能为以下几种：
>
>1. `H x`，表示向链表头插入一个数 $x$。
>2. `D k`，表示删除第 $k$ 个插入的数后面的数（当 $k$ 为 $0$ 时，表示删除头结点）。
>3. `I k x`，表示在第 $k$ 个插入的数后面插入一个数 $x$（此操作中 $k$ 均大于 $0$）。
>
>#### 输出格式
>
>共一行，将整个链表从头到尾输出。
>
>#### 数据范围
>
>$1≤M≤100000$
>所有操作保证合法。
>
>#### 输入样例：
>
>```
>10
>H 9
>I 1 1
>D 1
>D 0
>H 6
>I 3 6
>I 4 5
>I 4 5
>I 3 4
>D 6
>```
>
>#### 输出样例：
>
>```
>6 4 6 5
>```

#### 算法设计

这里引用单链表这个知识点肯定不是想直接用结构体定义的单链表。

因为使用结构体的方法，每次都需要 $\text{new}$ 一个新的结构体，这个操作是非常耗时的，对于 $\text{ACM}$ 这种每次都要操作 $100000$ 级别数据量的情况下是非常慢的。因为我们需要使用**数组**来模拟链表。

首先我们来明确模板中各个数组含义：

* $\text{head}$：头节点。

* $e_i$：节点 $i$ 的值。

* $ne_i$：节点 $i$ 的 $\text{next}$ 指针指向的节点。

* $\text{idx}$：存储当前已经用到了哪个点。

![image-20241214233109357](images/image-20241214233109357.png)

#### 完整 C++ 代码

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int m;
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;              // 下标-1表示为空
    idx = 0;
}

// 头插法插入
void add_to_head(int x)
{
    e[idx] = x, ne[idx] = head, head = idx ++;
}

// 在下标为 k 的数后面插入一个数 x

void add(int k, int x)
{   
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++;
}
// 在下标为 k 的数后面删掉一个数
void remove(int k)
{
   ne[k] = ne[ne[k]]; 
}

int main()
{
    cin >> m;
    init();
    while (m-- )
    {
        char op;
        cin >> op;
        if (op == 'H')
        {
            int x;
            cin >> x;
            add_to_head(x);
        }
        else if (op == 'D')
        {
            int k;
            cin >> k;
            if (!k) head = ne[head];
            remove(k - 1);
        }
        else
        {
            int k, x;
            cin >> k >> x;
            add(k - 1, x);
        }

    }
    
    for (int i = head; i != -1; i = ne[i]) cout << e[i] << " ";           // 标准的遍历方式
    return 0;
}

```











---

## KMP

> KMP：一个人能走的多远不在于他在顺境时能走的多快，而在于他在逆境时多久能找到曾经的自己 

### AcWing 831. KMP字符串

#### 题目描述

>给定一个字符串 $S$，以及一个模式串 $P$，所有字符串中只包含大小写英文字母以及阿拉伯数字。
>模式串 $P$ 在字符串 $S$ 中多次作为子串出现。
>求出模式串 $P$ 在字符串 $S$ 中所有出现的位置的起始下标。
>
>#### 输入格式
>
>第一行输入整数 $N$，表示模式串 $P$ 的长度。
>
>第二行输入字符串 $P$。
>
>第三行输入整数 $M$，表示字符串 $S$ 的长度。
>
>第四行输入字符串 $S$。
>
>#### 输出格式
>
>共一行，输出所有出现位置的起始下标（下标从 $0$ 开始计数），整数之间用空格隔开。
>
>#### 数据范围
>
>$ 1≤N≤10^5 $
>
>$ 1≤M≤10^6 $
>
>#### 输入样例：
>
>```
>3
>aba
>5
>ababa
>```
>
>#### 输出样例：
>
>```
>0 2
>```



#### 算法设计

$next[i]本质:模式串前i个字符的最长的一对相等的前后缀size(＝该前缀末端index)[下标从1开始]$
$如$:"$abab$", $size$=$2$

$每次循环开始的时候,j都=ne[i - 1]，下面分两种情况来讨论：$
$①.if\;\;p_{i}=p_{j+1}$
$\;\;\;\;\;\;\;\;\;\; ne[i] \gets ne[i - 1] + 1$
$②.if\;\;p_{i} \ne p_{j+1}$
$\;\;\;\;\;\;\;\;\;\; j \gets ne[j],再重新开始判断if\;(p_{i}=p_{j+1})$

```c++
// 求next数组过程:其实就是求最大前后缀长度，通过仿造下面KMP匹配的过程来求,可以将暴力求的o(n^2)复杂度降至o(n)
for (int i = 2, j = 0; i <= n; i++)           // 注意这里i得从2开始,因为默认ne[1]=0,如果这里i从1开始,很明显会导致ne[1]=1,最终代码会出现TLE
{
    while (j != 0 && p[i] != p[j + 1])  j = ne[j];   // 只要j没有退回起点,并且p[i]和p[j+1]不匹配,就可以通过next数组更新j
    if (p[i] == p[j + 1]) j++;   // 如果最终p[i]和p[j+1]相等,那么最长前后缀size就可以+1
    ne[i] = j;                   // 最后更新一下ne[i]
}
```

$每一次将字符串的s[i]和模式串的p[j + 1]进行匹配$

```c++
// KMP匹配过程:将s[i]与p[j + 1]进行匹配[当然这里为什么用j+1就说来话长了,毕竟当不匹配的时候是要对该下标前面的进行转移，所以与其用j-1，不如用j+1也就方便不越界了]
for (int i = 1, j = 0; i <= m; i++)
{
    while (j != 0 && s[i] != p[j + 1])  j = ne[j];   // 只要j没有退回起点,并且s[i]和p[j+1]不匹配,就可以通过next数组更新j
    if (s[i] == p[j + 1]) j++;                // 因为上面的循环结束有两种情况，1.j退回起点退无可退了，2.s[i]和p[j+1]终于匹配上了
    if (j == n)
    {
        cout <<  i - n << " ";                // 匹配成功,这里是根据题目要求的输出所有出现位置的起始下标（下标从0开始计数）
        j = ne[j];                           // 此时依旧使用next数组来更新使得省去已知匹配的前后缀
    }
}
```

$ \text{KMP} 算法可以视作状态机模型:基于字符串p的\text{KMP}自动机接受且仅接受以p为后缀的字符串，其接受状态为|p|。 $
$转移函数:$

$$ne(i, c) =
\begin{cases}
i + 1, & \text{if } p[i+1] = c \\
0, & \text{if } p[1] \neq c \land i = 0 \\
ne(\pi(i), c), & \text{if } p[i+1] \neq c \land i > 0
\end{cases}$$

#### 时间复杂度

$O(n+m)$

#### 完整 C++ 代码

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 100010, M = 1000010;

char p[N], s[M];             // pattern:模式串
int ne[N];                  // next数组

int main() 
{
    int n, m;
    cin >> n >> p + 1 >> m >> s + 1;

    // 求next数组过程:其实就是求最大前后缀长度，通过仿造下面KMP匹配的过程来求,可以将暴力求的o(n^2)复杂度降至o(n)
    for (int i = 2, j = 0; i <= n; i++)           // 注意这里i得从2开始,因为默认ne[1]=0,如果这里i从1开始,很明显会导致ne[1]=1,最终代码会出现TLE
    {
        while (j != 0 && p[i] != p[j + 1])  j = ne[j];   // 只要j没有退回起点,并且p[i]和p[j+1]不匹配,就可以通过next数组更新j
        if (p[i] == p[j + 1]) j++;   // 如果最终p[i]和p[j+1]相等,那么最长前后缀size就可以+1
        ne[i] = j;                   // 最后更新一下ne[i]
    }

    // KMP匹配过程:将s[i]与p[j + 1]进行匹配[当然这里为什么用j+1就说来话长了,毕竟当不匹配的时候是要对该下标前面的进行转移，所以与其用j-1，不如用j+1也就方便不越界了]
    for (int i = 1, j = 0; i <= m; i++)
    {
        while (j != 0 && s[i] != p[j + 1])  j = ne[j];   // 只要j没有退回起点,并且s[i]和p[j+1]不匹配,就可以通过next数组更新j
        if (s[i] == p[j + 1]) j++;                // 因为上面的循环结束有两种情况，1.j退回起点退无可退了，2.s[i]和p[j+1]终于匹配上了
        if (j == n)
        {
            cout <<  i - n << " ";                // 匹配成功,这里是根据题目要求的输出所有出现位置的起始下标（下标从0开始计数）
            j = ne[j];                           // 此时依旧使用next数组来更新使得省去已知匹配的前后缀
        }
    }
}
```

---







# 第三章 搜索与图论

## DFS

### AcWing 843. n-皇后问题

#### 题目描述

>### 843. n-皇后问题
>
>$n$-皇后问题是指将 $n$ 个皇后放在 $n×n$ 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。
>
>![1_597ec77c49-8-queens.png](https://cdn.acwing.com/media/article/image/2019/06/08/19_860e00c489-1_597ec77c49-8-queens.png)
>
>现在给定整数 $n$，请你输出所有的满足条件的棋子摆法。
>
>#### 输入格式
>
>共一行，包含整数 $n$。
>
>#### 输出格式
>
>每个解决方案占 $n$ 行，每行输出一个长度为 $n$ 的字符串，用来表示完整的棋盘状态。
>
>其中 `.` 表示某一个位置的方格状态为空，`Q` 表示某一个位置的方格上摆着皇后。
>
>每个方案输出完成后，输出一个空行。
>
>**注意：行末不能有多余空格。**
>
>输出方案的顺序任意，只要不重复且没有遗漏即可。
>
>#### 数据范围
>
>$1≤n≤9$
>
>#### 输入样例：
>
>```
>4
>```
>
>#### 输出样例：
>
>```
>.Q..
>...Q
>Q...
>..Q.
>
>..Q.
>Q...
>...Q
>.Q..
>```

#### 算法设计

首先我们来比较一下深度优先搜索和广度优先搜索这两种方式：

|              |    数据结构    |    空间    |     性质     |
| ------------ | :------------: | :--------: | :----------: |
| $\text{DFS}$ | $\text{Stack}$ | 递归耗空间 |  无“最短路”  |
| $\text{BFS}$ | $\text{Queue}$ | 迭代省空间 | "最短路"性质 |

这题是一道 $\text{DFS}$ 的经典模板题。

$\text{DFS}$ 有两步关键点：回溯，剪枝。

回溯其实就是 $\text{DFS}$ 的本身的一个特性，因为它每次都是先访问到搜索树的叶节点，然后返回再访问上一层节点，所以这就是一步回溯的操作，回溯需要恢复现场。

剪枝说的就是 $\text{DFS}$ 又名暴搜，其实本质上就是把每一种可能性都枚举了，但是在我们探索的过程中，其实就可以进行判断，如果可以确定这条路走不通，也就无需访问这条路径的叶子节点，可以减少很多时间，也被称为剪去搜索树的整个分枝。

同时由于每个点只能被走一次，所以无论是 $\text{DFS}$ 还是 $\text{BFS}$，我们基本都要开一个 bool 类型的 $st$ 数组来存储哪些点已经被我们走过了。

有了上面的一些基础知识，下面我们来分析这道题：

此题 $\text{DFS}$ 在探索时中传入的 $u$ 是当前处理的行号，因为每行只会放置一个皇后，因此就无需再开一个 $\text{row[N]}$ 来记录行信息，而这里对于放置的每个皇后后记录它所在正对角线和反对角线的方法很特殊。

我们可以使用编程坐标系来求解，也即行方向为 $x$ 方向，列方向为 $y$ 方向，所以此时我们传入的 $u$ 即 $x$ 坐标，$i$ 也就是 $y$ 坐标。

所以对于放置的每一个皇后，经过它的正对角线方程为 $y=x+b_1$，反对角线方程为 $y = -x + b_2$，所以 $\begin{cases}  b_1 = y-x  \\ b_2 = y+x \end{cases} $

故我们只需要记录一下所谓的每次放置的皇后所在对角线的 $b_1$ 点和 $b_2$ 点即可。

不过这里还有一个小细节，我们在计算$b_1=y-x$ 时，会有时候算出负值来，但是我们的数组下表不能有负值，所以这里我们直接记录 $b_1+n$ 即可保证合法，同时我们这里的正负对角线数组要开成 $2N$ 大小才能正确。

所以最终我们记录的是 $\begin{cases}  b_1+n = y-x+n  \\ b_2 = y+x \end{cases} $

#### 完整 C++ 代码

```c++
#include <iostream>

using namespace std;

const int N = 10, M = 2 * N;

int n;
char g[N][N];
bool col[N], dg[M], udg[M]; // col：记录列情况，dg：正对角线，udg：反对角线
                            // dfs和bfs基本都要开一个bool数组用来标记走过哪些点，因为
void dfs(int u)
{
    if (u == n)
    {
        for (int i = 0; i < n; i++) cout << g[i] << endl;
        cout << endl;
        return;
    }
    for (int i = 0; i < n; i ++)
    {
        if (!col[i] && !dg[i - u + n] && !udg[i + u])        // 剪枝
        {   
            g[u][i] = 'Q';
            col[i] = dg[i - u + n] = udg[i + u] = true;
            dfs(u + 1);
            col[i] = dg[i - u + n] = udg[i + u] = false;     // 回溯：恢复现场
            g[u][i] = '.';
        }
    }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++)
        for (int j = 0; j < n; j ++) 
            g[i][j] = '.';
    dfs(0);
    return 0;
}
```

---



## 树与图

### AcWing 846. 树的重心

#### 题目描述

>### 846. 树的重心
>
>给定一颗树，树中包含 $n$ 个结点（编号 $1∼n$）和 $n−1$ 条无向边。
>
>请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。
>
>重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。
>
>#### 输入格式
>
>第一行包含整数 $n$，表示树的结点数。
>
>接下来 $n−1$ 行，每行包含两个整数 $a$ 和 $b$，表示点 $a$ 和点 $b$ 之间存在一条边。
>
>#### 输出格式
>
>输出一个整数 $m$，表示将重心删除后，剩余各个连通块中点数的最大值。
>
>#### 数据范围
>
>$1≤n≤10^5$
>
>#### 输入样例
>
>```
>9
>1 2
>1 7
>1 4
>2 8
>2 5
>4 3
>3 9
>4 6
>```
>
>#### 输出样例：
>
>```
>4
>```

#### 算法设计

由于树是一种特殊的图，而无向边的图相当于画有两条有向边的图，所以我们只需要抽象出**有向图**的模板即可解决树和图的基本问题。

有向图一般有邻接矩阵和邻接表两种存储方式。

由于邻接矩阵对于稀疏图的效果不是很好，因此在 ACM 中我们一般不会使用，而是改用邻接表来存储。

首先我们来明确模板中各个数组含义：

* $h_i$：指向第 $i$ 个链表的头节点。

* $e_i$：存储节点 $i$ 的值。

* $ne_i$：存储节点 $i$ 的 $\text{next}$ 指针指向的节点。

* $\text{idx}$：存储当前已经用到了哪个点。

* $\text{st}$：记录搜索过程中已经走过哪些点了，因为这里把无向边替换成两条有向边，如果不记录就会回头，造成死循环。

这里的定义其实就和第二章单链表给出的模板基本一样，只是单链表只有一个头我们直接用 $\text{head}$ 就可以了，这里有多个头所以我们使用 $h$ 数组来表示某个头节点。

下面我们给出有向图的 $\text{DFS}$ 的代码框架：

```c++
const int N = 100010, M = N * 2;

int h[N], e[M], ne[M], idx;
bool st[N];     // dfs和bfs基本都要开一个bool数组用来标记走过哪些点，因为每个点只能被遍历一次

// 插入一条 a->b 的边
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

void dfs(int u)
{
    st[u] = true;  // 标记一下该点已经被走过了
    
    for (int i = h[u]; i != -1; i = ne[i])         // 和遍历单链表是一模一样的
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}

int main()
{
    memset(h, -1, sizeof h);            // 仿造链表初始化，将所以h都初始化为-1
}
```

下面我们来分析这道题，这道题是要求重心，所以我们需要思考：如何求删除某个点后剩余各个连通块中点数？

这个问题直接用 $DFS$ 就可以解决：

<img src="images/image-20241215234403577.png" alt="image-20241215234403577" style="zoom: 33%;" />

如图，我们思考一个一般性的情况：如果我们此时需要计算删除点 $4$ 之后剩余的 $1,2,3$ 号连通块的点数。

对于连通块 $2$ 和 $3$，我们可以通过 $\text{DFS}$ 在回溯的过程中将连通块 $\text{size}$ 返回，这样就可以知道连通块 $2$ 和 $3$ 的点数，但是对于连通块 $1$ 来说，无法通过返回值来求出来，这里我们可以使用一个技巧：$s_1=n-(sum_4)$。毕竟总节点数我们是知道的，所以只需要用总节点数减去节点 $4$ 这棵子树的总结点数就可以得到了。

#### 完整 C++ 代码

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010, M = N * 2;

int n;
int h[N], e[M], ne[M], idx;
bool st[N];        // dfs和bfs基本都要开一个bool数组用来标记走过哪些点，因为每个点只能被遍历一次
int ans = N;       // 记录一下全局的最小值


// 插入一条 a->b 的边
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

// 返回以u为根的子树中点的数量
int dfs(int u)
{
    st[u] = true;  // 标记一下该点已经被走过了
    
    int sum = 1;  // 记录当前子树的大小
    int res = 0;  // 把这个点删除后每一个连通块大小的最大值
    for (int i = h[u]; i != -1; i = ne[i])         // 和遍历单链表是一模一样的
    {
        int j = e[i];
        if (!st[j]) 
        {
            int s = dfs(j);
            sum += s;
            res = max(res, s);
        }
    }
    
    res = max(res, n - sum);            // 上面连通块这种情况单独处理
    
    ans = min(ans, res);
    return sum;
}

int main()
{   
    cin >> n;
    memset(h, -1, sizeof h);            // 仿造链表初始化，将所以h都初始化为-1
    
    for (int i = 0; i < n; i ++)
    {
        int a, b;
        cin >> a >> b;
        add(a, b);
        add(b, a);                      // 无向图视为两条有向边
    }
    dfs(1);                             // 这里从节点几开始搜都是可以的
    cout << ans << endl;
    
    return 0;
}
```

---



  



# 第四章 数学知识





# 第五章 动态规划

## DP问题初始化方式

**（小于等于，等于，大于）**

dp[i]:表示当体积`≤i`的所有情况集合下的最大价值[如**	AcWing2. 01背包问题**等]

```c++
// dp[0] = 0;       // 这种情况就是最基本的背包问题，无需特意初始化，只需要初值都是0就可以

......    

for (int j = m; j >= v; j--)   // 计算时严格保证任意状态下背包体积 >= 0
{
    dp[j] = max(dp[j], dp[j - v] + w);
}

......

cout << dp[m] << endl;         // 最大值就是简单的dp[m]
```

---

dp[i]:表示当体积`==i`的所有情况集合下的最大价值[如**AcWing12. 背包问题求具体方案**等]

```c++
memset(dp, -0x3f, sizeof dp);   // 初始化为∞（如果题目求max，就用+∞，求min，就用-∞）
dp[0] = 0;        // 对dp[0]作为起始点单独初始化,求最大价值就初始化为0，求方案数就初始化为1

......    

for (int j = m; j >= v; j--)    // 计算时严格保证任意状态下背包体积 >= 0
{
    dp[j] = max(dp[j], dp[j - v] + w);     
}

......

int res = 0;              // 注意这里是体积恰好为i的情况，所以最大值就不只是简单的dp[m]
for (int i = 0; i <= m; i++) res = max(res, dp[i]);      // 需要一层循环求结果
cout << res << endl;
```

---

dp[i]:表示当体积`≥i`的所有情况集合下的最小价值[如**AcWing1020. 潜水员**等]

```c++
memset(dp, 0x3f, sizeof dp);   // 初始化为∞（如果题目求max，就用+∞，求min，就用-∞）
dp[0] = 0;           // 对dp[0]作为起始点单独初始化,求最大价值就初始化为0，求方案数就初始化为1

......           

for (int j = m; j >= 0; j--)   // 计算时任意状态下背包的体积允许 < 0
{
    dp[j][k] = min(dp[j][k], dp[max(0, j-v1)][max(0, k-v2)]+w);   
}

......

cout << dp[m][n] << endl;     // 最大值需要自己判断，可能还是dp[m][n]
```

---

## 数字三角形模型

> 数字三角形模型应该算是dp中最简单的模型了

### AcWing 1018. 最低通行费

#### 题目描述

> 一个商人穿过一个 $N×N$ 的正方形的网格，去参加一个非常重要的商务活动。
>
> 他要从网格的左上角进，右下角出。
>
> 每穿越中间 $1$ 个小方格，都要花费 $1$ 个单位时间。
>
> 商人必须在 $(2N−1)$ 个单位时间穿越出去。
>
> 而在经过中间的每个小方格时，都需要缴纳一定的费用。
>
> 这个商人期望在规定时间内用最少费用穿越出去。
>
> 请问至少需要多少费用？
>
> 注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。
>
> #### 输入格式
>
> 第一行是一个整数，表示正方形的宽度 $N$。
>
> 后面 $N$ 行，每行 $N$ 个不大于 $100$ 的正整数，为网格上每个小方格的费用。
>
> #### 输出格式
>
> 输出一个整数，表示至少需要的费用。
>
> #### 数据范围
>
> $0<N≤100$
>
> #### 输入样例：
>
> ```
> 5
> 1  4  6  8  10
> 2  5  7  15 17
> 6  8  9  18 20
> 10 11 12 19 21
> 20 23 25 29 33
> ```
>
> #### 输出样例：
>
> ```
> 109
> ```
>

#### 算法设计

这题说的看起来很复杂，商人必须在 $(2N−1)$ 个单位时间穿越出去，其实用贪心发现最快方式也就是每次只往右或者下走，时间正好是 $(2N−1)$ 所以这题其实就是一道数字三角形的简单模板

#### 完整 C++ 代码

```c++
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 110;

int n;
int w[N][N];
int dp[N][N];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= n; j++) 
            cin >> w[i][j];
    memset(dp, 0x3f, sizeof dp);          // 求min就设置无穷大，方便后面就不用写if判断语句了
    dp[0][1] = 0;                       
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= n; j++)
            dp[i][j] = w[i][j] + min(dp[i - 1][j], dp[i][j - 1]);
    cout << dp[n][n] << endl;
    return 0;
}
```

---

## 最长上升子序列模型

### AcWing 895. 最长上升子序列

#### 题目描述

> 给定一个长度为 $N$ 的数列，求数值严格单调递增的子序列的长度最长是多少。
>
> #### 输入格式
>
> 第一行包含整数 $N$。
>
> 第二行包含 $N$ 个整数，表示完整序列。
>
> #### 输出格式
>
> 输出一个整数，表示最大长度。
>
> #### 数据范围
>
> $0<N≤1000$
>
> $−10^9≤$ 数列中的数 $≤109$
>
> #### 输入样例：
>
> ```
> 7
> 3 1 2 1 8 5 6
> ```
>
> #### 输出样例：
>
> ```
> 4
> ```

#### 算法设计

$f_i$ 表示所有以第 $i$ 个数结尾的上升子序列中的最大值

#### 完整C++ 代码

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int a[N], dp[N];

int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) {
        dp[i] = 1;
        for (int j = 1; j < i; j++) {
            if (a[i] > a[j]) dp[i] = max(dp[i], dp[j] + 1);
        }
    }
    int res = 0;
    for (int i = 1; i <= n; i++) res = max(res, dp[i]);
    cout << res << endl;
    return 0;
}
```

---

## 背包模型

### AcWing 5. 多重背包问题 II

#### 题目描述

> 有 $N$ 种物品和一个容量是 $V$ 的背包。
>
> 第 $i$ 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。
>
> 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
>
> 输出最大价值。
>
> #### 输入格式
>
> 第一行两个整数，$N$, $V$，用空格隔开，分别表示物品种数和背包容积。
>
> 接下来有 $N$ 行，每行三个整数 $v_i$, $w_i$, $s_i$，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。
>
> #### 输出格式
>
> 输出一个整数，表示最大价值。
>
> #### 数据范围
>
> $0<N≤1000$
> $0<V≤2000$
> $0<v_i, w_i, s_i≤2000$
>
> ##### 提示：
>
> 本题考查多重背包的二进制优化方法。
>
> #### 输入样例：
>
> ```
> 4 5
> 1 2 3
> 2 4 1
> 3 4 3
> 4 5 2
> ```
>
> #### 输出样例：
>
> ```
> 10
> ```

#### 算法设计

一个非常简洁的二进制优化自用板子

根据y总讲的AcWing7. 混合背包问题整理的板子，相当简洁还省空间

空间复杂度无需$O(n \log n)$,降为$O(max(n, log s))$

时间复杂度还是$O(n^2log n)$

#### 完整 C++ 代码

```c++
#include <iostream>

using namespace std;

const int N = 2010;
int dp[N];

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) 
    {
        int v, w, s;
        cin >> v >> w >> s;
        for (int k = 1; k <= s; k *= 2)            // 把s拆成二进制形式，如 10 = 2^0 + 2^1 + 2^2 + 3
        {
            for (int j = m; j >= k * v; j--)       // 对上面的分开形式进行01背包
            {
                dp[j] = max(dp[j], dp[j - k * v] + k * w);
            }
            s -= k;
        }
        if (s) {                                   // 处理刚刚拆开的二进制的最后一位
            for (int j = m; j >= s * v; j--)
            {
                dp[j] = max(dp[j], dp[j - s * v] + s * w);
            }
        }
    }
    cout << dp[m] << endl;
    return 0;
}

```

---

## 状态机模型

### AcWing 1058. 股票买卖 V

#### 题目描述

> 给定一个长度为 $N$ 的数组，数组中的第 $i$ 个数字表示一个给定股票在第 $i$ 天的价格。
>
> 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
>
> - 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
> - 卖出股票后，你无法在第二天买入股票 (即冷冻期为 $1$ 天)。
>
> #### 输入格式
>
> 第一行包含整数 $N$，表示数组长度。
>
> 第二行包含 $N$ 个不超过 $10000$ 的正整数，表示完整的数组。
>
> #### 输出格式
>
> 输出一个整数，表示最大利润。
>
> #### 数据范围
>
> $1≤N≤10^5$
>
> #### 输入样例：
>
> ```
> 5
> 1 2 3 0 2
> ```
>
> #### 输出样例：
>
> ```
> 3
> ```

#### 算法设计

状态分为：1. 手中有货，2. 手中无货的第 $1$ 天，3. 手中无货的第 $\ge2$ 天

#### 完整C++ 代码

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 100010, INF = 0x3f3f3f3f;

int dp[N][3];         // dp[i][0]:有货, dp[i][1]:手中无货的第1天, dp[i][2]:手中无货的第≥2天

int main() {
    int n;
    cin >> n;
    memset(dp, -0x3f, sizeof dp);

    dp[0][2] = 0;
    for (int i = 1; i <= n; i++)
    {
        int w;
        cin >> w;
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - w);
        dp[i][1] = dp[i - 1][0] + w;
        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1]);
    }
    cout << max(dp[n][1], dp[n][2]) << endl;
    return 0;
}
```

---

## 状态压缩DP

### AcWing 1064. 小国王

#### 题目描述

>### 1064. 小国王
>
>在 $n×n$ 的棋盘上放 $k$ 个国王，国王可攻击相邻的 $8$ 个格子，求使它们无法互相攻击的方案总数。
>
>#### 输入格式
>
>共一行，包含两个整数 $n$ 和 $k$ 。
>
>#### 输出格式
>
>共一行，表示方案总数，若不能够放置则输出$0$。
>
>#### 数据范围
>
>$1 \le n \le10$,
>$0 \le k \le n^2$
>
>#### 输入样例：
>
>```
>3 2
>```
>
>#### 输出样例：
>
>```
>16
>```

---

#### 算法设计

$f(i,j,s)$:所有只摆在前$i$行，已经摆了$j$个国王，并且第$i$行摆放的状态是$s$的所有方案的集合。

首先我们来看看暴力一点的做法，虽然我们提前对符合条件的值进行了预处理，但是依旧会超时。因为我们最后还是在最后状态转移阶段还是在遍历每一个二进制数，虽然判断其合法性的操作提前进行了预处理来降低了部分时间复杂度，但是依旧需要$O(N \times K \times 2^n \times 2^n)$,在这一题大概是$10^9$,会超时。

#### 暴力做法 C++ 代码

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 12, M = N * N, S = 1 << N;

int dp[N][M][S];
bool st[S];
int cnt[S];

int main()
{
    int n, m;
    cin >> n >> m;
    dp[0][0][0] = 1;

    for (int i = 0; i < 1 << n; i++)
    {
        st[i] = true;
        int num = 0;
        for (int u = 0; u < n; u++)
        {
            if (i >> u & 1)
            {
                num++;
                if (num > 1) st[i] = false;
            }
            else num = 0;
        }
        if (num > 1) st[i] = false;
    }    

    for (int i = 0; i < 1 << n; i++)
    {
        for (int u = 0; u < n; u++)
        {
            if (i >> u & 1) cnt[i]++;
        }
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j <= m; j++)
        {
            for (int k = 0; k < 1 << n; k++)
            {
                for (int u = 0; u < 1 << n; u++)
                {
                    if (k & u) continue;
                    if (!st[k | u]) continue;
                    if (cnt[k] <= j) dp[i][j][k] += dp[i - 1][j - cnt[k]][u];
                }
            }
        }
    }

    int res = 0;
    for (int i = 0; i < 1 << n; i++) res += dp[n][m][i];
    cout << res << endl;
    return 0;
}
```

进一步思考：如果我们把所有可能符合的值在预处理阶段存下来，那么我们在最终状态转移的时候，岂不是其实只需要在这些值里进行遍历，那么时间复杂度就可以进一步降低。

#### 优化版本 C++ 代码
```c++
#include <iostream>
#include <cstring>
#include <vector>

using namespace std;

const int N = 12, S = N * N, M = 1 << N;

int n, m;
long long dp[N][S][M];
int cnt[M];
vector<int> state;
vector<int> head[M];

bool check(int state)
{
    for (int u = 0; u < n; u++)
    {
        if ((state >> u & 1) && (state >> u + 1 & 1))
            return false;
    }
    return true;
}

int count(int state)
{
    int res = 0;
    for (int u = 0; u < n; u++) 
        if (state >> u & 1)
            res++;
    return res;
}

int main()
{
    cin >> n >> m;
    dp[0][0][0] = 1;

    for (int i = 0; i < 1 << n; i++)                        
    {   
        if (check(i)) 
        {
            state.push_back(i);                  // 预处理出来所有的不存在连续两个1的可能情况，后续只对这些情况进行循环
            cnt[i] = count(i);                   // 预处理出1的个数
        }
    }   


    for (int i = 0; i < state.size(); i++)
    {
        for (int j = 0; j < state.size(); j++)
        {
            int a = state[i];
            int b = state[j];
            if ((a & b) == 0 && check(a | b))     // ！！！:这里写成if ((a & b == 0) && check(a | b))是错误的，因为优先级
            {
                head[a].push_back(b);
            }
        }
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j <= m; j++)
        {
            for (int a = 0; a < state.size(); a++)
            {
                for (int b = 0; b < head[state[a]].size(); b++)
                {   
                    int c = cnt[state[a]];
                    if (j >= c) dp[i][j][state[a]] += dp[i - 1][j - c][head[state[a]][b]];
                }
            }
        }
    }

    long long res = 0;
    for (int i = 0; i < 1 << n; i++) res += dp[n][m][i];
    cout << res << endl;         // 或是更简单的在上一步循环时到 i<=n+1 结束，此时 res=dp[n+1][0]; 
    return 0;
}
```

---

## 区间DP

### AcWing 282. 石子合并

#### 题目描述

> #### 282. 石子合并
>
> 设有 $N$ 堆石子排成一排，其编号为 $1,2,3,…,N$。
>
> 每堆石子有一定的质量，可以用一个整数来描述，现在要将这 $N$ 堆石子合并成为一堆。
>
> 每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。
>
> 例如有 $4$ 堆石子分别为 `1 3 5 2`， 我们可以先合并 $1、2$ 堆，代价为 $4$，得到 `4 5 2`， 又合并 $1、2$ 堆，代价为 $9$，得到 `9 2` ，再合并得到 $11$，总代价为 $4+9+11=24$；
>
> 如果第二步是先合并 $2、3$堆，则代价为 $7$，得到 `4 7`，最后一次合并代价为 $11$，总代价为 $4+7+11=22$。
>
> 问题是：找出一种合理的方法，使总的代价最小，输出最小代价。
>
> ####  输入格式
>
> 第一行一个数 $N$ 表示石子的堆数 $N$。
>
> 第二行 $N$ 个数，表示每堆石子的质量(均不超过 $1000$)。
>
> #### 输出格式
>
> 输出一个整数，表示最小代价。
>
> #### 数据范围
>
> $1≤n≤300$
>
> #### 输入样例：
>
> ```
> 4
> 1 3 5 2
> ```
>
> ##### 输出样例：
>
> ```
> 22
> ```

---

#### 算法设计

这是区间 $\text{DP}$ 的一道经典的模板题，一般有两种解法：

* 迭代式：适合对于一维的情况

```
 for (int len = 2; len <= n; len++)                      // 一般就是先枚举区间长度len
     for (int L = 1; L + len - 1 <= n; L++)              // 然后枚举左端点
     {
		R = L + len - 1;                                 // 就可以推出右端点
     }
```

* 记忆化搜索：主要针对二维及以上的情况

对于此题来说，$f_{i,j}$ 表示所有将 $[i, j]$ 这个区间中的石子合并成一堆的方案的所有集合中的最小代价。

如果直接对 $i, j$ 进行从 $1∼n$ 进行迭代的话是错误的，因为这里的*状态转移*过程是将左右两堆已经合并好的合并成一个大堆，所以得先合并小堆。

所以区间 $ \text{DP}$ 这里比较特殊，我们对区间长度 $\text{len}$ 进行遍历，这样大区间就会依赖于小区间计算出来的结果。



#### 完整C++ 代码

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 310, INF = 0x3f3f3f3f;

int n;
int s[N], dp[N][N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++) 
    {
        cin >> s[i];
        s[i] += s[i - 1];
    }
    
    for (int len = 2; len <= n; len++)
        for (int l = 1; l + len - 1 <= n; l++)
        {
            int r = l + len - 1;
            dp[l][r] = INF;
            for (int d = l; d + 1 <= r; d++)              // 假设将区间划分成[l, d] 和 [d + 1, r]
            {
                dp[l][r] = min(dp[l][r], dp[l][d] + dp[d + 1][r] + (s[r] - s[l - 1]));
            }
        }
        
    // 或者下面初始化写法:
    // memset(dp, INF, sizeof dp);
    // for (int len = 1; len <= n; len++)
    //     for (int l = 1; l + len - 1 <= n; l++)
    //     {
    //         int r = l + len - 1;
    //         if (len == 1) dp[l][r] = 0;                   // 长度为1不需要代价
    //         else
    //         {
    //             for (int d = l; d + 1 <= r; d++)              // 假设将区间划分成[l, d] 和 [d + 1, r]
    //                 dp[l][r] = min(dp[l][r], dp[l][d] + dp[d + 1][r] + (s[r] - s[l - 1]));
    //         }
    //     }
    
    cout << dp[1][n] << endl;
}
```



#### 拓展

本题其实是还有一道变式

>### 320. 能量项链
>
>#### 题目描述
>
>在 $\text{Mars}$ 星球上，每个 $\text{Mars}$ 人都随身佩带着一串能量项链，在项链上有 $N$ 颗能量珠。
>
>能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。
>
>并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。
>
>因为只有这样，通过吸盘（吸盘是 $\text{Mars}$ 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。
>
>如果前一颗能量珠的头标记为 $m$，尾标记为 $r$，后一颗能量珠的头标记为 $r$，尾标记为 $n$，则聚合后释放的能量为 $m×r×n$（$\text{Mars}$ 单位），新产生的珠子的头标记为 $m$，尾标记为 $n$。
>
>需要时，$\text{Mars}$ 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。
>
>显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。
>
>例如：设 $N=4$，$4$ 颗珠子的头标记与尾标记依次为 $(2，3)(3，5)(5，10)(10，2)$。
>
>我们用记号 $⊕$ 表示两颗珠子的聚合操作，$(j⊕k)$ 表示第 $j$，$k$ 两颗珠子聚合后所释放的能量。则第 $4、1$ 两颗珠子聚合后释放的能量为：$(4⊕1)=10×2×3=60$。
>
>这一串项链可以得到最优值的一个聚合顺序所释放的总能量为 $((4⊕1)⊕2)⊕3)=10×2×3+10×3×5+10×5×10=710$。
>
>#### 输入格式
>
>输入的第一行是一个正整数 $N$，表示项链上珠子的个数。
>
>第二行是 $N$ 个用空格隔开的正整数，所有的数均不超过 $1000$，第 $i$ 个数为第 $i$ 颗珠子的头标记，当 $i<N$ 时，第 $i$ 颗珠子的尾标记应该等于第 $i+1$ 颗珠子的头标记，第 $N$ 颗珠子的尾标记应该等于第 $1$ 颗珠子的头标记。
>
>至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。
>
>#### 输出格式
>
>输出只有一行，是一个正整数 $E$，为一个最优聚合顺序所释放的总能量。
>
>#### 数据范围
>
>$4≤N≤100$,
>$1≤E≤2.1×10^9$
>
>#### 输入样例：
>
>```
>4
>2 3 5 10
>```
>
>#### 输出样例：
>
>```
>710
>```
>
>---
>
>#### 算法设计
>
>这题主要的变化在两个部分：
>
>1. 环形合并
>
>  这一题咋一看就和石子合并这一题基本一样，但是是个环形，所以这题可以简单思考为如何断链成一排石子。
>
>   很朴素的想法是，枚举每一个可能的断链点，如 $1,2...n$, 然后分别使用石子合并模板。
>
>   不好的消息是这种做法的时间复杂度是 $O(n^4)$, 这题给的 $n$ 范围在 $200$ 以内，会 $\text{TLE}$。
>
>   此题的通解是：
>$$
> \begin{matrix} 1\ \underbrace{ 2\ \ 3\dots \ n\ \ 1}\ 2\dots n \\ len=n \to \text{可以看作是环在 1,2 处断链} \end{matrix}
> $$
> 
> 
>   ​	即我们只需要构造一个长度为 $2n$ 的石子合并问题即可，后面 $n$ 堆的石子和前面 $n$ 堆石子完全一样，直接使用石子合并模板对这 $2n$ 堆石子进行求 $\max$ 和 $\min$ 即可。时间复杂度也从 $O(n^4)$ 降到 $O(n^3)$。
>
> 2. 聚合操作
>
>  这里的聚合操作不是简单的石子合并了，有点像矩阵的味道。
>
>   对于样例，$(2，3)(3，5)(5，10)(10，2)\to2,\ 3,\ 5,\ 10,\ 2$
>
>   将这 $4$ 颗能量珠抽象为 $5$ 个数，然后对这 $5$ 个数套用石子合并模板。
>
>   注意这里状态计算的时候，和石子合并不同，石子合并是将 $[l,r]$ 分成 $[l,d]$ 和 $[d+1, r]$ 两个区间；但是这里是划分成$[l,d]$ 和 $[d, r]$ 两个区间,这里的划分点 $d$ 是共用的:
>$$
>   \begin{matrix} \underbrace{ 2,\ 3,} \underbrace{ \ 5,\ 10,\ 2} \\ [2,3]\ \ \ \ [3,2] \end{matrix}
> $$
>   以及这里的区间长度最少从 $3$ 开始，因为 $\text{len}=2$ 时只是一颗能量珠，不需要合并，可以省去一次判断。
> 
>   以及最终的区间长度应该是 $n+1$。
>
> #### 完整C++代码
>
>```c++
>#include <iostream>
>
>using namespace std;
>
>const int N = 300;
>
>int n;
>int w[N], dp[N][N];
>
>int main()
>{
>   cin >> n;
>   for (int i = 1; i <= n; i++) {
>        cin >> w[i];
>        w[i + n] = w[i];
>    }
>    for (int len = 3; len <= n + 1; len++)       // 注意这里len得从3开始，且取到n+1
>        for (int l = 1; l + len - 1 <= n * 2; l++)
>        {
>            int r = l + len - 1;
>            for (int d = l + 1; d < r; d++)
>            {
>                dp[l][r] = max(dp[l][r], dp[l][d] + dp[d][r] + w[l] * w[d] * w[r]);
>            }
>        }
>    int res = 0;
>    for (int i = 1; i <= n; i++)
>    {
>        int j = i + n;               // 注意这里是因为区间长度为n+1
>        res = max(res, dp[i][j]);
>    }
>    cout << res << endl;
>    return 0;
> }
> ```

---

### AcWing 479. 加分二叉树

#### 题目描述

>### 479. 加分二叉树
>
>设一个 $n$ 个节点的二叉树 tree 的中序遍历为（$1,2,3,…,n$），其中数字 $1,2,3,…,n$ 为节点编号。
>
>每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下：     
>
>subtree 的左子树的加分 $×$ subtree 的右子树的加分 $+$ subtree 的根的分数 
>
>若某个子树为空，规定其加分为 $1$。
>
>叶子的加分就是叶节点本身的分数，不考虑它的空子树。
>
>试求一棵符合中序遍历为（$1,2,3,…,n$）且加分最高的二叉树 tree。
>
>要求输出： 
>
>（1）tree 的最高加分 
>
>（2）tree 的前序遍历
>
>#### 输入格式
>
>第 $1$ 行：一个整数 $n$，为节点个数。 
>
>第 $2$ 行：$n$ 个用空格隔开的整数，为每个节点的分数（$0<$分数$<100$）。
>
>#### 输出格式
>
>第 $1$ 行：一个整数，为最高加分（结果不会超过`int`范围）。     
>
>第 $2$ 行：$n$ 个用空格隔开的整数，为该树的前序遍历。如果存在多种方案，则输出字典序最小的方案。
>
>#### 数据范围
>
>$n<30$
>
>#### 输入样例：
>
>```
>5
>5 7 1 2 10
>```
>
>##### 输出样例：
>
>```
>145
>3 1 2 4 5
>```

#### 算法设计

这里选这题作为模板是因为这是一道求区间 $\text{DP}$ 具体方案的题目，和之前的石子合并求最大最小代价是不一样的。

求区间 $\text{DP}$ 具体方案的通用做法是：

通过使用 $g_{i,j}$ 记录区间 $[i,j]$ 中最大价值时的划分点 $d$ ，在使用完区间合并模板后，只需要使用一次 $\text{dfs}$ 即可找到每一次最大价值的划分点。

#### 完整C++ 代码

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 50, INF = 0x3f3f3f3f;

int n;
int w[N];
int dp[N][N], g[N][N];

void dfs(int l, int r)
{   
    if (l > r) return;
    int d = g[l][r];
    cout << d << " ";
    dfs(l, d - 1);
    dfs(d + 1, r);
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> w[i];
    memset(dp, -INF, sizeof dp);
    
    for (int len = 1; len <= n; len++)
        for (int l = 1; l + len - 1 <= n; l++)
        {
            int r = l + len - 1;
            if (len == 1)           // 这题因为对len=1情况特殊规定了，所以得使用模板的第2种写法
            {
                dp[l][r] = w[l];
                g[l][r] = l;
            }
            else
                for (int d = l; d <= r; d++)
                {   
                    int left = dp[l][d - 1], right = dp[d + 1][r];
                    if (d == l)     // 题目种
                        left = 1;
                    if (d == r)
                        right = 1;
                    if (dp[l][r] < left * right + w[d])
                    {
                        dp[l][r] = left * right + w[d];
                        g[l][r] = d;
                    }
                }
        }
    cout << dp[1][n] << endl;
    dfs(1, n);
    return 0;
}
```

---



## 树形DP

### AcWing 1072. 树的最长路径

#### 题目描述

>### 1072. 树的最长路径
>
>给定一棵树，树中包含 $n$ 个结点（编号$1∼n$）和 $n−1$ 条无向边，每条边都有一个权值。
>
>现在请你找到树中的一条最长路径。
>
>换句话说，要找到一条路径，使得使得路径两端的点的距离最远。
>
>注意：路径中可以只包含一个点。
>
>#### 输入格式
>
>第一行包含整数 $n$。
>
>接下来 $n−1$ 行，每行包含三个整数 $a_i,b_i,c_i$，表示点 $a_i$ 和 $b_i$ 之间存在一条权值为 $c_i$ 的边。
>
>#### 输出格式
>
>输出一个整数，表示树的最长路径的长度。
>
>#### 数据范围
>
>$1≤n≤10000$,
>$1≤ai,bi≤n$,
>$−10^5≤ci≤10^5$
>
>#### 输入样例：
>
>```
>6
>5 1 6
>1 4 5
>6 3 9
>2 6 8
>6 1 7
>```
>
>#### 输出样例：
>
>```
>22
>```

#### 算法设计

首先我们先来证明图论中的一个经典结论：**对于没有负边权的树，如何找树的直径？**

1. 任取一点作为起点，找到距离该点最远的一个点 $u$。
2. 再找到距离 $u$ 最远的一点 $v$。

此时 $uv$ 就是我们要找的一条直径。

也即我们只需要使用两次 $\text{BFS}$ 在$O(n)$的时间复杂度里便可找到我们需要的直径。

下面我们对这个经典结论进行证明：

其实这个证明等价于证明 $1$ 中我们所找到的 $u$ 是某条直径的一个端点。

我们假设任意选取的一个起点为 $a$，反证法假设 $u$ 不是任意一条直径的一条端点，我们假设有一条直径 $bc$。

1. $bc$ 和 $au$ 没有交点。由于树的定义，这两条线一定是连通的，我们假设 $au$ 中存在一点 $x$ 与 $bc$ 中的 $y$ 存在一条路径 $xy$。根据定义 $u$ 是我们找到的距离 $a$ 最远的一个点，易得 $xu \ge xy+yc$，所以 $xu+xy \ge yc$，故 $byxu \ge byc$，又由 $byc$ 是直径，所以 $byxu$ 一定也是直径，所以 $u$ 一定是直径的一个端点。
2. $bc$ 和 $au$ 没有交点。我们假设交点为 $x$，即我们有 $bxc$ 和 $axu$ 两条直线。根据定义 $u$ 是我们找到的距离 $a$ 最远的一个点，易得 $xu \ge xc$，所以 $bxu \ge bxc$，又由 $bxc$ 是直径，所以 $bxu$ 一定也是直径，所以 $u$ 一定是直径的一个端点。

综上所述，$u$ 一定是某条直径的一个端点。

对于本题来说，边权可以为负，故证明中的第一种情况里的由 $xu \ge xy+yc$ 便推不出 $xu+xy \ge yc$ 来了，所以两次 $\text{BFS}$ 无法得到我们要的直径了。所以我们需要使用更一般的方法：树形 DP 来求解此题。

本质上 DP 只是对暴搜的一种优化：减少重复计算。

这里就是通过将所有路径的值存到这条路径所经过的所有点中最高的那个点里，下面我们该如何更新经过每个点的路径的最大值呢？

我们将这个问题抽象出一个一般模型，如图所示，假设我们需要求出经过点 $u$ 的路径的最大值？

<img src="images/image-20241216162813641.png" alt="image-20241216162813641" style="zoom:50%;" />

我们可以通过 $\text{DFS}$ 的返回值来分别得到点 $u$ 在子树 $1,2,3$ 中的往下走的一个最大的路径长度，然后通过 $d_i=s_i+w_i$ 便可得到这些子树上的经过 $u$ 的最长路径 $d_i$，然后通过统计出这些最长路径中的最大值 $m_1$ 和次大值 $m_2$（需要 $>0$），$m_1 + m_2$ 就是我们要求的经过点 $u$ 的路径的最大值。

这里求最大值 $m_1$ 和次大值 $m_2$ 可以使用一个技巧：

1. $m_1, m_2$ 初值设置为0（可以保证后续更新后的 $m_1,m_2$ 也是 $>0$ 的）。
2. 如果每次算出来的 $d \ge m_1$，我们就令 $m_2 = m_1$，$m_1 = d$。（这里更新顺序不能反）
3. 如果每次算出来的 $d < m_1$，但是 $d >m_2$，我们就令 $m_2=d$。

以及这里使用了 $\text{st}$ 数组来确保每个点只走一次，有种 DP 减少重复计算的味道在里面。

#### 完整 C++ 代码

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10010, M = N * 2;

int n;
int h[N], w[M], e[M], ne[M], idx;
bool st[N];
int ans;

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

// 返回过根节点的最长路径
int dfs(int u)
{
    st[u] = true;
    
    int m1 = 0, m2 = 0;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            int d = dfs(j)+ w[i];
            if (d >= m1) 
                m2 = m1, m1 = d;     // 注意这里不能m1 = d, m2 = m1,
            else if (d > m2)
                m2 = d;
        }
    }
    ans = max(ans, m1 + m2);
    return m1;
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        h[i] = -1;
    for (int i = 1; i < n; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
        add(b, a, c);
    }
    dfs(1);
    cout << ans << endl;
    return 0;
}
```

#### 拓展

刚刚的一道题其实是利用子节点信息去逐步更新父节点信息，但是还有一些更变态的题目还需要再利用父节点信息去更新子节点信息，我们一起来看看下面收录的这道题吧。

> ### 1073. 树的中心
>
> 给定一棵树，树中包含 $n$ 个结点（编号11~nn）和 n−1n−1 条无向边，每条边都有一个权值。
>
> 请你在树中找到一个点，使得该点到树中其他结点的最远距离最近。
>
> #### 输入格式
>
> 第一行包含整数 nn。
>
> 接下来 n−1n−1 行，每行包含三个整数 ai,bi,ciai,bi,ci，表示点 aiai 和 bibi 之间存在一条权值为 cici 的边。
>
> #### 输出格式
>
> 输出一个整数，表示所求点到树中其他结点的最远距离。
>
> #### 数据范围
>
> 1≤n≤100001≤n≤10000,
> 1≤ai,bi≤n1≤ai,bi≤n,
> 1≤ci≤1051≤ci≤105
>
> #### 输入样例：
>
> ```
> 5 
> 2 1 1 
> 3 2 1 
> 4 3 1 
> 5 1 1
> ```
>
> #### 输出样例：
>
> ```
> 2
> ```
>
> ---
>
> #### 算法设计
>
> xxx
>
> #### 完整 C++ 代码
>
> ```c++
> 
> ```
>
> xxx
>
> 



---

## 记忆化搜索

### AcWing 901. 滑雪

#### 题目描述

>### 901. 滑雪
>
>给定一个 $R$ 行 $C$ 列的矩阵，表示一个矩形网格滑雪场。
>
>矩阵中第 $i$ 行第 $j$ 列的点表示滑雪场的第 $i$ 行第 $j$ 列区域的高度。
>
>一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。
>
>当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。
>
>下面给出一个矩阵作为例子：
>
>```
>1  2  3  4  5
>
>16 17 18 19 6
>
>15 24 25 20 7
>
>14 23 22 21 8
>
>13 12 11 10 9
>```
>
>在给定矩阵中，一条可行的滑行轨迹为 $24−17−2−1$。
>
>在给定矩阵中，最长的滑行轨迹为 $25−24−23−…−3−2−1$，沿途共经过 $25$ 个区域。
>
>现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。
>
>#### 输入格式
>
>第一行包含两个整数 $R$ 和 $C$。
>
>接下来 $R$ 行，每行包含 $C$ 个整数，表示完整的二维矩阵。
>
>#### 输出格式
>
>输出一个整数，表示可完成的最长滑雪长度。
>
>#### 数据范围
>
>$1≤R,C≤300$,
>$0≤$矩阵中整数$≤10000$
>
>#### 输入样例：
>
>```
>5 5
>1 2 3 4 5
>16 17 18 19 6
>15 24 25 20 7
>14 23 22 21 8
>13 12 11 10 9
>```
>
>#### 输出样例：
>
>```
>25
>```

#### 算法设计

此题是记忆化搜索的一道模板题，这道题用常规的迭代式 dp 写法，会发现状态转移不好写，也就是所有状态的起点不知道在哪。

当遇到这种情况或者循环太复杂如 $f_{i,j,k,m,n}$，常规情况需要写五层循环转移状态，会发现很不好写，如果用记忆化搜索来写会发现会很容易翻译成代码。记忆化搜索其实就是递归式的 dp 写法。

#### 完整 C++ 代码

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 310;

int n, m;
int w[N][N], dp[N][N];

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

int dfs(int x, int y)
{
    int &v = dp[x][y];
    if (v == -1) return v;                     // 说明还没走过这个状态
    
    v = 1;                                     // v可以只走当前格子，就是1
    for (int i = 0; i < 4; i++)
    {
        int a = x + dx[i];
        int b = y + dy[i];
        if (a >= 1 && a <= n && b >= 1 && b <= m && w[x][y] < w[a][b])
            v = max(v, dfs(a, b) + 1);
    }
    return v;
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> w[i][j];
    
    memset(dp, -1, sizeof dp);                 // 首先把每个状态初始化为-1，表示未被算过
            
    int res = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            res = max(res, dfs(i, j));
    cout << res << endl;
    return 0;
}
```

---

# 第六章 贪心













## 推公式

### AcWing 125. 耍杂技的牛

#### 题目描述

>### 125. 耍杂技的牛
>
>农民约翰的 $N$ 头奶牛（编号为 $1\dots N$）计划逃跑并加入马戏团，为此它们决定练习表演杂技。
>
>奶牛们不是非常有创意，只提出了一个杂技表演：
>
>叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。
>
>奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。
>
>这 $N$ 头奶牛中的每一头都有着自己的重量 $W_i$ 以及自己的强壮程度 $S_i$。
>
>一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。
>
>您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。
>
>#### 输入格式
>
>第一行输入整数 $N$，表示奶牛数量。
>
>接下来 $N$ 行，每行输入两个整数，表示牛的重量和强壮程度，第 $i$ 行表示第 $i$ 头牛的重量 $W_i$ 以及它的强壮程度 $S_i$。
>
>#### 输出格式
>
>输出一个整数，表示最大风险值的最小可能值。
>
>#### 数据范围
>
>$1≤N≤50000$,
>$1≤W_i≤10,000$,
>$1≤S_i≤1,000,000,000$
>
>#### 输入样例：
>
>```
>3
>10 3
>2 5
>3 3
>```
>
>#### 输出样例：
>
>```
>2
>```

#### 算法设计

我们首先将牛进行堆叠，从上往下进行依次编号，定义第 $i$ 头牛的重量为 $W_i$，强壮程度为 $S_i$。

|  牛   |             风险值             |
| :---: | :----------------------------: |
|  $i$  |  $\sum_{j=1}^{i-1} w_j - s_i$  |
| $i+1$ | $\sum_{j=1}^{i} w_j - s_{i+1}$ |

我们假设需要交换这两个才能得到最优解，即：

|  牛   |          交换前风险值          |              交换后风险值              |
| :---: | :----------------------------: | :------------------------------------: |
|  $i$  |  $\sum_{j=1}^{i-1} w_j - s_i$  | $\sum_{j=1}^{i-1} w_j + w_{i+1} - s_i$ |
| $i+1$ | $\sum_{j=1}^{i} w_j - s_{i+1}$ |    $\sum_{j=1}^{i-1} w_j - s_{i+1}$    |

进一步化简式子得：

|  牛   |  交换前风险值   |   交换后风险值   |
| :---: | :-------------: | :--------------: |
|  $i$  |     $- s_i$     | $ w_{i+1} - s_i$ |
| $i+1$ | $w_i - s_{i+1}$ |   $- s_{i+1}$    |

首先我们观察到：交换这头牛并不会带来前后其他牛的风险值的变化

* $i$ 之前的牛并不涉及牛 $i$ 和 $i+1$ 的重量
* $ i $ 之后的牛只涉及到牛 $i$ 和 $i+1$ 的总重量

由于$ w_{i+1} - s_i > s_i$，如果我们使用贪心的思想，假设 $ w_{i+1} - s_i>w_i - s_{i+1}$，此时交换后的牛 $i$ 的风险值同时大于交换前的牛 $i$ 和 $i+1$ 的风险值，那么交换后的风险值的最大值肯定大于交换前，所以此时我们不应该交换。

通过等价变换，原不等式 $ w_{i+1} - s_i>w_i - s_{i+1}$ 可改写为 $w_{i+1} +s_{i+1}>w_i +  s_i $。

由此可得只需要满足：如果将牛按照 $w_i +  s_i $ 排序后堆叠，小的值在上面，即可使得所有牛的风险值中的最大值尽可能的小。

下面我们对上面的结论进行证明：

假设我们贪心得到的做法不是最优解，那么将牛进行堆叠，一定存在某一次操作，最优解是需要将更小的 $w_i +  s_i $  堆在更大的 $w_{i+1} +s_{i+1}$ 下面，那么如果此时我们将牛 $i$ 和 $i+1$ 进行交换，那么由之前的证明可知，一定会增加这两头牛的风险值中的最大值，那么此时最优解得到的最大值一定大于我们贪心得到的最大值，故与最优解的定义矛盾。

综上可得将牛按照 $w_i +  s_i $ 排序后堆叠是最优解。

#### 完整 C++ 代码

```c++
#include <iostream>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;

const int N = 50010;

PII cow[N];

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        int w, s;
        cin >> w >> s;
        cow[i] = {w + s, s};
    }
    sort(cow, cow + n);              // 可以用反证法证明所有牛按照w+s从小到大排序来安排是最优解
    int sum = 0;
    int res = -1e9;
    for (int i = 0; i < n; i++)
    {
        res = max(res, sum - cow[i].second);
        sum += cow[i].first - cow[i].second;
    }
    cout << res << endl;
    
    return 0;
}
```

---

# 第七章 时空复杂度分析

## 由数据范围反推算法复杂度以及算法内容

一般 $\text{ACM}$ 或者笔试题的时间限制是 $1$ 秒或 $2$ 秒，
在这种情况下，$\text{C}$++ 代码中的操作次数控制在 $10^7 \sim 10^8$ 为最佳。
下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择:

1. $n \le 30$,指数级别,dfs+剪枝，状态压缩dp

2. $n \le 10^2 =>O(n^3)$，floyd，dp，高斯消元

3. $n \le 10^3 => O(n^2)$，$O(n^2log n)$，dp，二分，朴素版Dikstra、朴素版Prim、Bellman-Ford

4. $n \le 10^4 => O(n\sqrt{n})$，块状链表、分块、莫队

5. $n \le 10^5 =>O(nlogn)=>$各种sort，线段树、树状数组、setmap、heap、拓扑排序、dikstratheap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树

6. $n\le 10^6 =>O(n)$,以及常数较小的 $O(nlogn)$ 算法 $=>$ 单调队列、hash、双指针扫描、BFS、并查集,
   kmp、AC自动机，常数比较小的 $O(nlogn)$ 的做法:sort、树状数组、heap、dikstra、spfa

7. $n \le 10^7 =>O(n)$，双指针扫描、kmp、AC自动机、线性筛素数
8. $n \le 10^9=>O(\sqrt n)$，判断质数

9. $n \le 10^{18} =>O(logn)$，最大公约数，快速幂，数位DP
10. $n\le 10^{1000} => O((logn)^2)$，高精度加减乘除. 
11. $n\le 10^{100000} => 0(logk \ast loglogk)$，$k$表示位数，高精度加减、FFT/NTT
